<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Constructing Egocentric Neighborhood Networks:</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="02_neighborhood_networks_files/libs/clipboard/clipboard.min.js"></script>
<script src="02_neighborhood_networks_files/libs/quarto-html/quarto.js"></script>
<script src="02_neighborhood_networks_files/libs/quarto-html/popper.min.js"></script>
<script src="02_neighborhood_networks_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="02_neighborhood_networks_files/libs/quarto-html/anchor.min.js"></script>
<link href="02_neighborhood_networks_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="02_neighborhood_networks_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="02_neighborhood_networks_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="02_neighborhood_networks_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="02_neighborhood_networks_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: rgba(0, 0, 0, 0.8);
      }

      .quarto-title-block .quarto-title-banner {
        color: rgba(0, 0, 0, 0.8);
background: featured.jpg;
      }
</style>


<link rel="stylesheet" href="custom.scss">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Constructing Egocentric Neighborhood Networks:</h1>
            <p class="subtitle lead">Methodological Framework</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">Abstract</div>
      <p>This paper presents an innovative methodological framework that integrates recent advances in neighborhood effects research with social contagion theory to analyze how spatial and social processes interact in urban environments. We build upon the concept of “bespoke neighborhoods” - spatially-defined social networks centered on individual locations - to examine how different types of social influence operate across various spatial scales and urban contexts. Our framework advances beyond traditional approaches by incorporating both simple and complex contagion mechanisms while accounting for the multi-scalar nature of neighborhood effects. Drawing on high-resolution geographic data and detailed social connection patterns, we develop a comprehensive methodology that enables researchers to examine the nuanced ways in which spatial proximity and social influence intersect. This framework represents a significant methodological advance that allows for more precise measurement of both neighborhood effects and social contagion mechanisms, with important implications for urban research and policy.</p>
    </div>
  </div>
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">En este ejercicio</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#theoretical-foundation" id="toc-theoretical-foundation" class="nav-link" data-scroll-target="#theoretical-foundation">Theoretical Foundation</a>
  <ul class="collapse">
  <li><a href="#the-evolution-of-neighborhood-effects-research" id="toc-the-evolution-of-neighborhood-effects-research" class="nav-link" data-scroll-target="#the-evolution-of-neighborhood-effects-research">The Evolution of Neighborhood Effects Research</a></li>
  <li><a href="#integrating-social-contagion-theory" id="toc-integrating-social-contagion-theory" class="nav-link" data-scroll-target="#integrating-social-contagion-theory">Integrating Social Contagion Theory</a></li>
  </ul></li>
  <li><a href="#methodological-framework" id="toc-methodological-framework" class="nav-link" data-scroll-target="#methodological-framework">Methodological Framework</a>
  <ul class="collapse">
  <li><a href="#constructing-bespoke-networks" id="toc-constructing-bespoke-networks" class="nav-link" data-scroll-target="#constructing-bespoke-networks">Constructing Bespoke Networks</a></li>
  <li><a href="#analyzing-social-contagion-mechanisms" id="toc-analyzing-social-contagion-mechanisms" class="nav-link" data-scroll-target="#analyzing-social-contagion-mechanisms">Analyzing Social Contagion Mechanisms</a></li>
  </ul></li>
  <li><a href="#empirical-validation-and-applications" id="toc-empirical-validation-and-applications" class="nav-link" data-scroll-target="#empirical-validation-and-applications">Empirical Validation and Applications</a>
  <ul class="collapse">
  <li><a href="#validation-approach" id="toc-validation-approach" class="nav-link" data-scroll-target="#validation-approach">Validation Approach</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Contemporary urban research increasingly recognizes that neighborhood effects operate through multiple simultaneous mechanisms at various spatial scales. Traditional approaches, which rely on administrative boundaries and assume uniform social influence within defined areas, fail to capture the complex ways in which spatial and social processes interact in urban environments. Recent work by <span class="citation" data-cites="petrovic_where_2022">Petrović, Van Ham, and Manley (<a href="#ref-petrovic_where_2022" role="doc-biblioref">2022</a>)</span> has challenged this conventional wisdom by introducing the concept of “bespoke neighborhoods” - flexible, individual-centered spatial units that better reflect the actual scale at which neighborhood effects operate. Simultaneously, research on urban mobility patterns by <span class="citation" data-cites="wang_urban_2018">Wang et al. (<a href="#ref-wang_urban_2018" role="doc-biblioref">2018</a>)</span> has demonstrated that while residents of different socioeconomic groups may travel similar distances, they experience fundamentally different types of social exposure through their movement patterns.</p>
<p>Our framework builds upon these insights by integrating them with social contagion theory, particularly the distinction between simple and complex contagion mechanisms identified by <span class="citation" data-cites="centola_complex_2007">Centola and Macy (<a href="#ref-centola_complex_2007" role="doc-biblioref">2007</a>)</span>. This integration allows us to examine how different types of social influence operate across various spatial scales and social contexts. The result is a methodological approach that moves beyond static, administrative definitions of neighborhoods to capture the dynamic interplay between spatial proximity and social influence.</p>
<p>The innovation in our approach lies in the systematic combination of three key theoretical advances: the concept of bespoke neighborhoods, the understanding of differential mobility patterns, and the distinction between simple and complex social contagion mechanisms. This integration enables a more nuanced and accurate analysis of how social processes operate in urban spaces, with important implications for both research and policy.</p>
</section>
<section id="theoretical-foundation" class="level1">
<h1>Theoretical Foundation</h1>
<section id="the-evolution-of-neighborhood-effects-research" class="level2">
<h2 class="anchored" data-anchor-id="the-evolution-of-neighborhood-effects-research">The Evolution of Neighborhood Effects Research</h2>
<p>Research on neighborhood effects has traditionally been constrained by reliance on administrative boundaries and static definitions of social context. However, as <span class="citation" data-cites="petrovic_where_2022">Petrović, Van Ham, and Manley (<a href="#ref-petrovic_where_2022" role="doc-biblioref">2022</a>)</span> demonstrate, there is no theoretical reason to assume that neighborhood effects operate at a constant single spatial scale across different urban settings or time periods. Their introduction of bespoke neighborhoods represents a crucial methodological advance, allowing researchers to examine how spatial context effects vary when altering the spatial scale of analysis.</p>
<p>This insight aligns with empirical findings from mobility research. <span class="citation" data-cites="wang_urban_2018">Wang et al. (<a href="#ref-wang_urban_2018" role="doc-biblioref">2018</a>)</span> show that while residents of disadvantaged neighborhoods travel similar distances and visit similar numbers of neighborhoods as those from more advantaged areas, the composition of the neighborhoods they visit varies significantly. This finding suggests that meaningful social networks cannot be captured by arbitrary administrative units but must instead be constructed based on actual patterns of movement and interaction.</p>
</section>
<section id="integrating-social-contagion-theory" class="level2">
<h2 class="anchored" data-anchor-id="integrating-social-contagion-theory">Integrating Social Contagion Theory</h2>
<p>Our framework extends these insights by incorporating social contagion theory, particularly the distinction between simple and complex contagion mechanisms. Simple contagion processes, characterized by linear adoption probabilities and decreasing marginal effects of additional exposure, operate differently from complex contagion processes, which require multiple source validation and exhibit threshold effects. Understanding how these different mechanisms operate across various spatial scales is crucial for accurately modeling neighborhood effects.</p>
</section>
</section>
<section id="methodological-framework" class="level1">
<h1>Methodological Framework</h1>
<section id="constructing-bespoke-networks" class="level2">
<h2 class="anchored" data-anchor-id="constructing-bespoke-networks">Constructing Bespoke Networks</h2>
<p>Our approach centers on constructing spatially-defined social networks that reflect both physical proximity and social connection patterns. Unlike traditional approaches that rely on administrative boundaries, these networks are centered on individual locations and can vary in scale to capture different types of social processes. This construction allows us to examine how simple and complex contagion mechanisms operate at different spatial scales and across different urban contexts.</p>
<p>The methodology involves several key innovations:</p>
<p>First, we use high-resolution geographic data to create multi-scale spatial buffers around individual locations. These buffers are not fixed but vary based on urban structure and movement patterns, reflecting the insight from <span class="citation" data-cites="petrovic_where_2022">Petrović, Van Ham, and Manley (<a href="#ref-petrovic_where_2022" role="doc-biblioref">2022</a>)</span> that the relevant scale of neighborhood effects varies across urban contexts.</p>
<p>Second, we incorporate social connection data to weight these spatial relationships, acknowledging that physical proximity alone does not determine social influence. This integration allows us to examine how different types of social ties operate across space and how they interact with spatial proximity to facilitate or inhibit social contagion processes.</p>
</section>
<section id="analyzing-social-contagion-mechanisms" class="level2">
<h2 class="anchored" data-anchor-id="analyzing-social-contagion-mechanisms">Analyzing Social Contagion Mechanisms</h2>
<p>Our framework enables the systematic analysis of both simple and complex contagion processes within these bespoke networks. For simple contagion processes, we examine how influence decays with distance and how it varies across different types of social ties. For complex contagion processes, we analyze threshold effects and the role of multiple source validation in different spatial contexts.</p>
<p>[Detailed methodological equations and specifications would follow here]</p>
</section>
</section>
<section id="empirical-validation-and-applications" class="level1">
<h1>Empirical Validation and Applications</h1>
<section id="validation-approach" class="level2">
<h2 class="anchored" data-anchor-id="validation-approach">Validation Approach</h2>
<p>The framework can be validated through multiple complementary approaches. First, we can examine how well our bespoke networks predict observed patterns of social influence compared to traditional administrative boundaries. Second, we can test whether the distinction between simple and complex contagion processes helps explain variations in influence patterns across different types of behaviors and different urban contexts.</p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-centola_complex_2007" class="csl-entry" role="listitem">
Centola, Damon, and Michael Macy. 2007. <span>“Complex Contagions and the Weakness of Long Ties.”</span> <em>American Journal of Sociology</em> 113 (3): 702–34. <a href="https://doi.org/10.1086/521848">https://doi.org/10.1086/521848</a>.
</div>
<div id="ref-petrovic_where_2022" class="csl-entry" role="listitem">
Petrović, Ana, Maarten Van Ham, and David Manley. 2022. <span>“Where Do Neighborhood Effects End? Moving to Multiscale Spatial Contextual Effects.”</span> <em>Annals of the American Association of Geographers</em> 112 (2): 581–601. <a href="https://doi.org/10.1080/24694452.2021.1923455">https://doi.org/10.1080/24694452.2021.1923455</a>.
</div>
<div id="ref-wang_urban_2018" class="csl-entry" role="listitem">
Wang, Qi, Nolan Edward Phillips, Mario L. Small, and Robert J. Sampson. 2018. <span>“Urban Mobility and Neighborhood Isolation in America’s 50 Largest Cities.”</span> <em>Proceedings of the National Academy of Sciences</em> 115 (30): 7735–40. <a href="https://doi.org/10.1073/pnas.1802537115">https://doi.org/10.1073/pnas.1802537115</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>